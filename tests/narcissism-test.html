document.addEventListener("DOMContentLoaded", () => { const introSection =
document.getElementById("intro-section"); const startTestBtn =
document.getElementById("start-test-btn"); const testContainer =
document.getElementById("test-container"); const resultsContainer =
document.getElementById("results-container"); const form =
document.getElementById("narcissism-form"); const faqSection =
document.getElementById("faq-section"); const questions = [ { c: 1, q: "Когда вы
делитесь своими достижениями, партнер:", a: "reaction_to_success", }, { c: 1, q:
"Как партнер описывает свои прошлые отношения или неудачи на работе?", a:
"past_failures", }, { c: 2, q: "Если вы проводите время с друзьями без него/нее,
как он(а) реагирует?", a: "reaction_to_absence", }, { c: 2, q: "Как партнер
реагирует, если вы не сразу отвечаете на его/ее сообщения?", a:
"reaction_to_text", }, { c: 3, q: "Когда вы делитесь своими переживаниями,
партнер:", a: "reaction_to_feelings", }, { c: 3, q: "Замечает ли партнер, когда
у вас плохое настроение, без ваших слов?", a: "notice_mood", }, { c: 4, q: "Как
партнер ведет себя в очередях или в пробках?", a: "patience_in_line", }, { c: 4,
q: "Когда вы в чем-то не согласны, как партнер доказывает свою правоту?", a:
"argument_style", }, { c: 5, q: "Как партнер просит о помощи или услуге?", a:
"asking_for_help", }, { c: 5, q: "После ссоры, кто обычно делает первый шаг к
примирению?", a: "making_up", }, { c: 6, q: "Как партнер комментирует внешность
или успех других людей?", a: "commenting_on_others", }, { c: 6, q: "Как партнер
реагирует на конструктивную критику в свой адрес?", a: "reaction_to_criticism",
}, { c: 7, q: "Как часто вы слышите о грандиозных планах партнера, которые так и
не реализуются?", a: "grand_plans", }, ]; const answerOptions = {
reaction_to_success: [ { text: "Искренне радуется и гордится мной", value: 0 },
{ text: "Поздравляет, но быстро переводит тему на себя", value: 2 }, { text:
"Находит способ обесценить: 'Ну, это же легко было'", value: 3, }, { text:
"Игнорирует или злится", value: 4 }, { text: "Ко мне не относится", value: 0 },
], past_failures: [ { text: "Признает свои ошибки и извлекает уроки", value: 0
}, { text: "Рассказывает, но с юмором", value: 1 }, { text: "Всегда виноваты
другие (бывшие, начальники)", value: 3 }, { text: "Никогда не говорит о
неудачах, у него(нее) их нет", value: 4, }, { text: "Ко мне не относится",
value: 0 }, ], reaction_to_absence: [ { text: "Радуется, что я хорошо провожу
время", value: 0 }, { text: "Немного ревнует, но в шутку", value: 1 }, { text:
"Требует постоянных отчетов и фото", value: 3 }, { text: "Устраивает скандал или
наказывает молчанием", value: 4 }, { text: "Ко мне не относится", value: 0 }, ],
reaction_to_text: [ { text: "Спокойно, понимает, что я могу быть занят(а)",
value: 0 }, { text: "Спрашивает, все ли в порядке", value: 1 }, { text:
"Отправляет много сообщений и звонит", value: 3 }, { text: "Обвиняет в
игнорировании", value: 4 }, { text: "Ко мне не относится", value: 0 }, ],
reaction_to_feelings: [ { text: "Внимательно слушает и поддерживает", value: 0
}, { text: "Пытается дать совет, не вникая в суть", value: 2 }, { text: "Говорит
'не драматизируй' или 'успокойся'", value: 3 }, { text: "Начинает рассказывать,
как ему(ей) хуже", value: 4 }, ], notice_mood: [ { text: "Да, почти всегда",
value: 0 }, { text: "Иногда, если все очевидно", value: 1 }, { text: "Редко,
нужно прямо говорить", value: 3 }, { text: "Никогда, он(а) слишком занят(а)
собой", value: 4 }, ], patience_in_line: [ { text: "Спокойно ждет, как и все",
value: 0 }, { text: "Заметно нервничает и вздыхает", value: 2 }, { text:
"Пытается найти способ пройти без очереди", value: 3 }, { text: "Громко
возмущается и требует особого отношения", value: 4, }, { text: "Ко мне не
относится", value: 0 }, ], argument_style: [ { text: "Приводит факты и готов(а)
к компромиссу", value: 0 }, { text: "Давит авторитетом и громкостью", value: 2
}, { text: "Переходит на личности и оскорбления", value: 3 }, { text: "Искажает
мои слова и факты (газлайтинг)", value: 4 }, { text: "Мы не спорим", value: 0 },
], asking_for_help: [ { text: "Просит вежливо и всегда благодарит", value: 0 },
{ text: "Формулирует как приказ, но благодарит", value: 2 }, { text: "Требует
немедленно, злится при отказе", value: 3 }, { text: "Манипулирует: 'Если любишь,
то сделаешь'", value: 4 }, ], making_up: [ { text: "Тот, кто был неправ,
извиняется первым", value: 0 }, { text: "Чаще всего я", value: 2 }, { text:
"Всегда я, иначе будет молчать неделями", value: 3 }, { text: "Он(а) никогда не
извиняется", value: 4 }, { text: "Мы не ссоримся", value: 0 }, ],
commenting_on_others: [ { text: "Делает комплименты или нейтрален(льна)", value:
0 }, { text: "Часто критикует и находит недостатки", value: 2 }, { text:
"Отпускает злые и завистливые комментарии", value: 3 }, { text: "Сравнивает меня
с другими (не в мою пользу)", value: 4 }, { text: "Ко мне не относится", value:
0 }, ], reaction_to_criticism: [ { text: "Прислушивается и благодарит за
обратную связь", value: 0 }, { text: "Оправдывается и ищет виноватых", value: 2
}, { text: "Обижается и замыкается в себе", value: 3 }, { text: "Впадает в
ярость и контратакует", value: 4 }, { text: "Ко мне не относится", value: 0 },
], grand_plans: [ { text: "Никогда или очень редко", value: 0 }, { text: "Иногда
мечтает вслух", value: 1 }, { text: "Довольно часто, но ничего не делает",
value: 3 }, { text: "Постоянно, и злится, что мир его/ее не ценит", value: 4 },
], }; const criterionData = { 1: { label: "Грандиозность", emoji: "👑", color:
"#8b5cf6" }, 2: { label: "Жажда восхищения", emoji: "⭐", color: "#ec4899" }, 3:
{ label: "Отсутствие эмпатии", emoji: "💔", color: "#3b82f6" }, 4: { label:
"Чувство превосходства", emoji: "🧐", color: "#f59e0b" }, 5: { label:
"Эксплуатация", emoji: "🎭", color: "#10b981" }, 6: { label: "Зависть и
высокомерие", emoji: "😒", color: "#ef4444" }, 7: { label: "Фантазии о величии",
emoji: "🚀", color: "#a855f7" }, }; const storageKey = "narcissismTestAnswers";
let answeredQuestions = 0; const lenis = new Lenis({ lerp: 0.07, smoothWheel:
true }); function raf(time) { lenis.raf(time); requestAnimationFrame(raf); }
requestAnimationFrame(raf); startTestBtn.addEventListener("click", () => {
introSection.classList.add("fade-out"); introSection.addEventListener(
"animationend", () => { introSection.classList.add("hidden");
testContainer.classList.remove("hidden");
testContainer.classList.add("fade-in"); renderQuestions(); }, { once: true } );
}); function saveState() { const formData = new FormData(form); const answers =
{}; for (const [name, value] of formData.entries()) { answers[name] = value; }
localStorage.setItem(storageKey, JSON.stringify(answers)); } function
loadState() { const savedAnswers = localStorage.getItem(storageKey); if
(savedAnswers) { const answers = JSON.parse(savedAnswers);
Object.entries(answers).forEach(([name, value]) => { const radio =
form.querySelector( `input[name="${name}"][value="${value}"]` ); if (radio) {
radio.checked = true; const container = radio.closest(".grid"); container
.querySelectorAll(".option-card") .forEach((card) =>
card.classList.remove("selected"));
radio.parentElement.classList.add("selected"); const questionBlock =
radio.closest(".question-block"); if
(!questionBlock.hasAttribute("data-answered")) {
questionBlock.setAttribute("data-answered", "true"); answeredQuestions++; } }
}); updateProgress(); } } function updateProgress() { const progress =
(answeredQuestions / questions.length) * 100;
document.getElementById("progress-fill").style.width = progress + "%"; }
function renderQuestions() { questions.forEach((qData, index) => { const block =
document.createElement("div"); block.className = "question-block fade-in"; const
questionText = document.createElement("p"); questionText.className =
"font-medium text-lg text-gray-100 mb-4"; questionText.textContent = `${index +
1}. ${qData.q}`; block.appendChild(questionText); const optionsContainer =
document.createElement("div"); optionsContainer.className = "grid grid-cols-1
sm:grid-cols-2 lg:grid-cols-3 gap-3"; const currentAnswerSet =
answerOptions[qData.a]; currentAnswerSet.forEach((opt) => { const label =
document.createElement("label"); label.className = "option-card p-4 rounded-xl
text-center cursor-pointer flex items-center justify-center min-h-[60px]"; const
radio = document.createElement("input"); radio.type = "radio"; radio.name =
`q${index}`; radio.value = opt.value; radio.required = true;
label.appendChild(radio); label.append(opt.text);
optionsContainer.appendChild(label); }); block.appendChild(optionsContainer);
form.appendChild(block); }); loadState(); } form.addEventListener("change", (e)
=> { if (e.target.type === "radio") { const container =
e.target.closest(".grid"); container .querySelectorAll(".option-card")
.forEach((card) => card.classList.remove("selected"));
e.target.parentElement.classList.add("selected"); const questionBlock =
e.target.closest(".question-block"); if
(!questionBlock.hasAttribute("data-answered")) {
questionBlock.setAttribute("data-answered", "true"); answeredQuestions++;
updateProgress(); } saveState(); } }); form.addEventListener("submit", (e) => {
e.preventDefault(); if (answeredQuestions < questions.length) { const
unansweredBlock = form.querySelector( ".question-block:not([data-answered])" );
if (unansweredBlock) { lenis.scrollTo(unansweredBlock, { offset: -150 }); }
return; } const scores = calculateScores(); renderResults(scores);
localStorage.removeItem(storageKey); }); function calculateScores() { const
formData = new FormData(form); let criterionScores = {};
Object.keys(criterionData).forEach((key) => { criterionScores[key] = { sum: 0,
count: 0 }; }); questions.forEach((q, index) => { const value =
parseInt(formData.get(`q${index}`), 10) || 0; criterionScores[q.c].sum += value;
criterionScores[q.c].count++; }); let finalScores = {}; let totalScore = 0; let
maxPossibleScore = 0; Object.keys(criterionData).forEach((key) => { const { sum,
count } = criterionScores[key]; const maxScore = 4 * count; finalScores[key] = {
percentage: maxScore > 0 ? (sum / maxScore) * 100 : 0, }; totalScore += sum;
maxPossibleScore += maxScore; }); finalScores.overallPercentage =
maxPossibleScore > 0 ? (totalScore / maxPossibleScore) * 100 : 0; return
finalScores; } function renderResults(scores) {
testContainer.classList.add("fade-out"); testContainer.addEventListener(
"animationend", () => { testContainer.classList.add("hidden");
resultsContainer.classList.remove("hidden");
resultsContainer.classList.add("fade-in");
faqSection.classList.remove("hidden"); faqSection.classList.add("fade-in");
lenis.scrollTo(0); }, { once: true } ); const verdictEl =
document.createElement("div"); verdictEl.id = "overall-verdict";
verdictEl.className = "text-2xl md:text-3xl font-bold mb-4"; const descriptionEl
= document.createElement("p"); descriptionEl.id = "result-description";
descriptionEl.className = "text-gray-400 leading-relaxed"; const gaugeWrapper =
document.createElement("div"); gaugeWrapper.id = "gauge-wrapper";
gaugeWrapper.className = "mx-auto"; const interpretationDiv =
document.createElement("div"); interpretationDiv.id = "detailed-interpretation";
interpretationDiv.className = "space-y-6"; const overallPercentage =
Math.round(scores.overallPercentage); let verdictColorClass; if
(overallPercentage >= 70) { verdictEl.innerHTML = "Высокая вероятность
нарциссических черт"; verdictColorClass = "text-red-400";
descriptionEl.textContent = "Результаты указывают на значительное присутствие
нарциссических паттернов. Рекомендуется консультация с психологом для более
глубокого анализа ситуации."; } else if (overallPercentage >= 40) {
verdictEl.innerHTML = "Умеренные нарциссические черты"; verdictColorClass =
"text-yellow-400"; descriptionEl.textContent = "Обнаружены некоторые
нарциссические черты, которые могут влиять на качество отношений. Важно обратить
внимание на проблемные области."; } else { verdictEl.innerHTML = "Низкий уровень
нарциссических черт"; verdictColorClass = "text-green-400";
descriptionEl.textContent = "Нарциссические черты выражены слабо. Это указывает
на здоровые паттерны поведения в отношениях."; }
verdictEl.classList.add(verdictColorClass); gaugeWrapper.innerHTML = `
<div class="gauge-container">
  <div class="gauge-value">${overallPercentage}</div>
</div>
`; resultsContainer.innerHTML = `
<div class="glass-panel rounded-3xl p-8 md:p-12 shadow-2xl">
  <div class="text-center mb-12">
    <h2 class="display-font text-4xl md:text-5xl font-bold mb-4">
      Ваш <span class="gradient-text">Результат</span>
    </h2>
  </div>
  <div class="flex flex-col md:flex-row items-center gap-12 mb-12">
    ${gaugeWrapper.outerHTML}
    <div class="flex-1 text-center md:text-left">
      ${verdictEl.outerHTML} ${descriptionEl.outerHTML}
    </div>
  </div>
  <h3 class="text-2xl font-bold text-center mb-8">
    Детальная разбивка по критериям
  </h3>
  <div id="detailed-interpretation-placeholder" class="space-y-6"></div>
</div>

<!-- Review Section Start -->
<div
  id="review-section"
  class="mt-12 glass-panel rounded-3xl p-8 md:p-12 shadow-2xl"
>
  <h3 class="text-2xl font-bold text-center mb-2">Оцените этот тест</h3>
  <p class="text-gray-400 text-center mb-6">
    Ваш отзыв поможет нам стать лучше
  </p>
  <div id="review-form-container">
    <div class="star-rating mb-6">
      <input type="radio" id="star5" name="rating" value="5" /><label
        for="star5"
        >★</label
      >
      <input type="radio" id="star4" name="rating" value="4" /><label
        for="star4"
        >★</label
      >
      <input type="radio" id="star3" name="rating" value="3" /><label
        for="star3"
        >★</label
      >
      <input type="radio" id="star2" name="rating" value="2" /><label
        for="star2"
        >★</label
      >
      <input type="radio" id="star1" name="rating" value="1" /><label
        for="star1"
        >★</label
      >
    </div>
    <input
      type="text"
      id="review-name"
      class="review-input mb-4"
      placeholder="Ваше имя (необязательно)"
      maxlength="50"
    />
    <textarea
      id="review-text"
      class="review-input mb-6"
      placeholder="Напишите ваш отзыв здесь... (необязательно)"
    ></textarea>
    <div class="text-center">
      <button id="submit-review-btn" class="btn-premium">
        Отправить отзыв
      </button>
    </div>
  </div>
  <div
    id="review-message"
    class="text-center text-green-400 font-semibold text-lg hidden"
  ></div>
</div>
<!-- Review Section End -->

<div class="mt-12 text-center space-y-4">
  <button onclick="location.reload()" class="btn-premium">
    Пройти тест заново
  </button>
  <div>
    <a href="../../index.html" class="text-purple-400 hover:text-purple-300"
      >Вернуться к списку тестов →</a
    >
  </div>
</div>
`; const interpretationPlaceholder = document.getElementById(
"detailed-interpretation-placeholder" );
Object.keys(criterionData).forEach((key, index) => { const data =
criterionData[key]; const scoreData = scores[key]; const percentage =
Math.round(scoreData.percentage); const criterionEl =
document.createElement("div"); criterionEl.className = "fade-in";
criterionEl.style.animationDelay = `${index * 0.1}s`; criterionEl.innerHTML = `
<div class="flex items-center justify-between mb-2">
  <div class="flex items-center">
    <span class="text-2xl mr-3">${data.emoji}</span>
    <span class="font-semibold text-white">${data.label}</span>
  </div>
  <span class="font-bold text-lg" style="color: ${data.color}"
    >${percentage}%</span
  >
</div>
<div class="criterion-bar-bg">
  <div
    class="criterion-bar-fill"
    style="width: 0%; background-color: ${data.color}; --bar-color: ${data.color};"
  ></div>
</div>
`; interpretationPlaceholder.appendChild(criterionEl); }); setTimeout(() => {
document .querySelectorAll(".criterion-bar-fill") .forEach((bar, index) => {
const key = Object.keys(criterionData)[index]; const percentage =
Math.round(scores[key].percentage); bar.style.width = `${percentage}%`; }); },
100); setupReviewForm(); } function setupReviewForm() { const submitBtn =
document.getElementById('submit-review-btn'); const reviewFormContainer =
document.getElementById('review-form-container'); const reviewMessage =
document.getElementById('review-message'); submitBtn.addEventListener('click',
() => { const ratingInput =
document.querySelector('input[name="rating"]:checked'); const reviewText =
document.getElementById('review-text').value; const reviewName =
document.getElementById('review-name').value; if (!ratingInput) {
alert('Пожалуйста, поставьте оценку.'); return; } const rating =
parseInt(ratingInput.value, 10); const name = reviewName.trim() === '' ?
'Аноним' : reviewName; // Вставляем ваш URL из Formspree const formspreeUrl =
'https://formspree.io/f/xpwloayd'; submitBtn.disabled = true;
submitBtn.textContent = 'Отправка...'; const formData = { rating: rating, text:
reviewText, name: name, _subject: `Новый отзыв (${rating}★) для теста на
нарциссизм`, }; fetch(formspreeUrl, { method: 'POST', headers: { 'Content-Type':
'application/json', 'Accept': 'application/json' }, body:
JSON.stringify(formData), }) .then(response => { if (response.ok) {
reviewFormContainer.classList.add('hidden'); reviewMessage.textContent =
'Спасибо за ваш отзыв!'; reviewMessage.classList.remove('hidden'); } else {
throw new Error('Network response was not ok.'); } }) .catch(error => {
console.error('Error submitting review:', error); reviewMessage.textContent =
'Произошла ошибка. Попробуйте позже.'; reviewMessage.classList.remove('hidden',
'text-green-400'); reviewMessage.classList.add('text-red-400');
reviewFormContainer.classList.add('hidden'); }); }); } });
